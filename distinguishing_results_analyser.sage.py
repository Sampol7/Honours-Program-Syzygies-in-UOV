

# This file was *autogenerated* from the file distinguishing_results_analyser.sage
from sage.all_cmdline import *   # import sage library

_sage_const_10000 = Integer(10000); _sage_const_0 = Integer(0); _sage_const_267 = Integer(267); _sage_const_293 = Integer(293); _sage_const_280 = Integer(280); _sage_const_266 = Integer(266); _sage_const_306 = Integer(306); _sage_const_273 = Integer(273); _sage_const_281 = Integer(281); _sage_const_275 = Integer(275); _sage_const_287 = Integer(287); _sage_const_307 = Integer(307); _sage_const_278 = Integer(278); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_4 = Integer(4); _sage_const_11p4803 = RealNumber('11.4803'); _sage_const_12p659 = RealNumber('12.659'); _sage_const_9p2157 = RealNumber('9.2157'); _sage_const_16p747 = RealNumber('16.747'); _sage_const_15p747 = RealNumber('15.747'); _sage_const_7p443 = RealNumber('7.443'); _sage_const_5p143 = RealNumber('5.143')
import math

def manipulate_list(input_list):
    # Step 1: Calculate the mean of the list
    mean_value = sum(input_list) / len(input_list)
    print(mean_value)
    
    # Step 2: Divide the mean by 10,000
    mean_divided = mean_value / _sage_const_10000 
    print(mean_divided)
    
    # Step 3: Take the logarithm base 2 of the result
    if mean_divided > _sage_const_0 :
        log_result = math.log2(mean_divided)
    else:
        raise ValueError("Logarithm undefined for non-positive values.")
    
    return log_result

# Example usage:
example_list = [_sage_const_267 , _sage_const_293 , _sage_const_280 , _sage_const_266 , _sage_const_306 , _sage_const_273 , _sage_const_281 , _sage_const_275 , _sage_const_287 , _sage_const_307 , _sage_const_278 ]
result = manipulate_list(example_list)
print("Result:", result)


import numpy as np
from sympy import symbols, Matrix

def find_multivariate_polynomial(X1, X2, Y):
    """
    Finds a multivariate polynomial that maps two input lists X1, X2
    to the output list Y.
    
    Args:
    X1: First input list
    X2: Second input list
    Y: Output list
    
    Returns:
    The symbolic multivariate polynomial as a string.
    """
    # Ensure the inputs have the same length
    assert len(X1) == len(X2) == len(Y), "Input lists must have the same length"
    
    # Define the symbolic variables for the polynomial
    x1, x2 = symbols('x1 x2')
    
    # Create a matrix to represent the polynomial terms
    terms = []
    
    # Choose the degree of the polynomial (assumed degree 2 for simplicity, can be adjusted)
    for i in range(_sage_const_3 ):  # x1^0, x1^1, x1^2
        for j in range(_sage_const_2 ):  # x2^0, x2^1, x2^2
            terms.append(x1**i * x2**j)
    
    # Create the system of equations (Vandermonde-like matrix)
    A = []
    for x1_val, x2_val in zip(X1, X2):
        row = [term.subs({x1: x1_val, x2: x2_val}) for term in terms]
        A.append(row)
    
    # Convert A to numpy array for solving
    A = np.array(A, dtype=float)
    
    # Solve for the coefficients
    coeffs = np.linalg.lstsq(A, Y, rcond=None)[_sage_const_0 ]
    
    # Construct the symbolic polynomial
    polynomial = sum(c * term for c, term in zip(coeffs, terms))
    
    return polynomial

# Example usage:
n = [_sage_const_5 ,_sage_const_5 ,_sage_const_5 ,_sage_const_6 ,_sage_const_6 ,_sage_const_6 ,_sage_const_4 ,_sage_const_4 ]
m = [_sage_const_3 ,_sage_const_2 ,_sage_const_4 ,_sage_const_3 ,_sage_const_4 ,_sage_const_5 ,_sage_const_2 ,_sage_const_3 ]
Y = [-_sage_const_11p4803 ,-_sage_const_12p659 ,-_sage_const_9p2157 ,-_sage_const_16p747 ,-_sage_const_15p747 , -_sage_const_15p747 ,-_sage_const_7p443 ,-_sage_const_5p143 ]

polynomial = find_multivariate_polynomial(n, m, Y)
print(f"The multivariate polynomial is: {polynomial}")


